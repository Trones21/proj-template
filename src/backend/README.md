### Structure Overview:
```
project-name/
├── cmd/                # Application entry points
│   └── app/
│       └── main.go     # Main HTTP server
├── db/                 # Database-related files
│   ├── migrations/     # Database migration files
│   ├── sqlc.yaml       # SQLC configuration
│   ├── queries/        # SQL query files
|   |-- sqlcgen         # Files generated by SQLc with sqlc generate
│   └── models.go       # SQLC-generated models
├── internal/           # Internal application logic
│   ├── handlers/       # HTTP handlers
│   ├── services/       # Business logic
│   ├── repositories/   # ONLY custom written DB interaction logic, most DB wrappers in the sqlcgen folder 
│   └── utils/          # Utility functions (e.g., logging)
├── configs/            # Configuration files
│   └── config.yaml
├── Dockerfile          # Docker setup
├── docker-compose.yml  # Docker Compose for services
├── go.mod              # Go module dependencies
└── go.sum              # Dependency checksums

```
---

### Setup
Ensure en vars are set correctly, check: 
`~/env_setup/`
can also
```bash
env | grep DB_*
```
#### Postgres
Ensure migrations have been run

Postgres needs to have uuid extension enabled (this is also in migrations/_setup.sql)
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

##### Testing RDS Connection
 - RDS requires you to use sslmode=require
```bash
psql "host=<get from env> port=5432 dbname=pk_projName user=trones password=<get from env> sslmode=require"
```


#### Running outside of Container (Dev)
```bash
go run cmd/app/main.go 
```

####  Docker

##### Build, Transfer, Run a Single Docker Container

- Normally we use docker deploy.sh... but this just gives us an idea of the steps
```bash
docker build 
-t <image-name>:<tag> #-t name and tag for the image 
. # . : The build context is the directory whose files Docker can access during the build.

#if you want to see the images created, run
docker images
```

###### Run Locally 
```bash
Run
docker run -d \     # -d Runs the container in detached mode.
-p 8080:80     \    # -p maps the ports <machinePort>:<containerPort>
--name <container-name> <image-name>:<tag> 

docker ps # Verify it is running 

# Debugging 
docker logs <container-name> #Check the logs
docker inspect <container-name> | grep -i "port" # inspect port mappings 

# Cleanup
docker stop <container-name>
docker rm <container-name>
```

###### Run on Server
```bash
# Now we need to create the .tar file 
docker save -o ./dist/whatever.tar  <image-name>:<tag>

# Transfer image
scp whatever.tar anotherArchive.tar $SERVER:$REMOTE_PATH

# Then on server
docker load < /path/to/destination/backend.tar
docker run -d --name backend-container -p 8080:8080 backend:init

```

##### Providing Environment vars
Either manually with -e or pass a .env file 
```bash
docker run \ -e <key>=<value> \  # pass environment variable, m use one -e per env var

# FOR THIS PROJECT WE ACTUALLY LOAD OUR ENV VIA BASH, SO WE WILL NEED TO PULL THE ACTUAL VALUES INTO A FILE AFTER SETTING
source ~/env_setup/prod_backend.sh #load env vars from source of truth
env | grep -E 'DB_HOST|DB_PORT|DB_USER|DB_PASS|DB_NAME|BREVO_API_KEY' > .env_prod # can be named anything
docker run --env-file .env_prod 

```
- Script to generate .env_prod `./generate_dot_env_prod.sh` 
- General Reminder: the Env file must live in a place that the docker build context has access to


#### to stop and remove all containers and images
```bash
docker rm $(docker ps -aq)
docker rmi $(docker images -q)
```


##### Traefik Notes



##### Watchtower Notes
Watchtower monitors running containers and automatically pulls updated images from a container repository (like Docker Hub, AWS ECR, or GitHub Container Registry).
If it detects a new version of an image, it stops the running container, updates the image, and restarts the container.
**Since we are not using a container repository, we dont need to run watchtower**
but in the future this may be a good option 

### SQLC 
SQLc will generate models and query wrappers e.g. db.queryrowContext based on the sql files in `db/queries`. (see sqlc.yaml for specifics (config))

`db/migrations` and `db/queries` are written by the developers 

#### Create Go Files

```bash
sqlc generate # omit file flag when pwd == dir of sqlc.yaml
sqlc generate --file ./db/sqlc.yaml  #if running from backend folder
```

**generate_sqlc_yaml.sh**
Alternate approach for sqlc.yaml
Problem: we need to specify which schemas are available to which query folders 
Solution: generate a sqlc.yaml that lists all the schemas on each package 

Or just manage the sqlc.yaml file myself...
This can be tedious, but it's also better code that is generated.

---

### Migrate (Bash Scripts) 
Script will normalize the path. 
Outputs the count of tables vs .sql files in migrations dir
```bash 
bash create_tables.sh
```


### Testing 

"Request Flows" folder is found at the root of the project (sibling to backend). These allow you to send a series of requests (with logic in between). We are simulating what a user might do in the frontend, but its automated and there is no browser...

```bash
go run main.go #pwd is request_flows folder
```

##### ToDo:
Add Air for hotreloading 




